#include "invertedindex.hpp"

#include <iostream>
#include <string>
#include <unordered_map>

#include "doclen.hpp"

InvertedIndex::InvertedIndex(const std::unordered_set<std::string> &docs)
	: docs{ docs }
	, indexPair{ makeIndexPair() }
{
	// printInvertedIndex();
}

std::string InvertedIndex::key(char letter, std::size_t pos) const
{
	return std::string{ letter, static_cast<char>(pos + '0') };
}

const std::unordered_set<std::string> &InvertedIndex::at(char	     letter,
							 std::size_t pos) const
{
	return indexPair.first.at(key(letter, pos));
}

std::size_t InvertedIndex::frequency(char letter, std::size_t pos) const
{
	return indexPair.second.at(key(letter, pos));
}

std::unordered_set<std::string> InvertedIndex::makeKeys(void) const
{
	std::unordered_set<std::string> keys{};
	keys.reserve(MAX_KEYS);
	for (const auto &doc : docs) {
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			keys.emplace(key(doc[i], i));
		}
		if (keys.size() == 130) {
			break;
		}
	}
	return keys;
}

// void InvertedIndex::printIndices(void) const
// {
// 	for (const auto &i : indices) {
// 		std::cout << i << "\n";
// 	}
// 	std::cout << indices.size() << "\n";
// }

IndexPair InvertedIndex::makeIndexPair(void) const
{
	auto	  keys{ makeKeys() };
	IndexPair indexPair{};
	indexPair.first.reserve(keys.size());
	indexPair.second.reserve(keys.size());
	for (const auto &i : keys) {
		char	    letter = i[0];
		std::size_t pos	   = i[1] - '0';
		for (const auto &doc : docs) {
			if (doc[pos] == letter) {
				indexPair.first[i].insert(doc);
			}
		}
		indexPair.second[i] = indexPair.first[i].size();
	}
	return indexPair;
}

void InvertedIndex::printInvertedIndex(void) const
{
	std::size_t ctr = 0;
	for (const auto &[key, value] : indexPair.first) {
		std::cout << "{ " << key << " }: [";
		std::size_t i = 0;
		ctr += value.size();
		for (auto it = value.begin(); it != value.end(); it++, i++) {
			if (i == value.size() - 1) {
				std::cout << *it << "]\n";
				break;
			}
			std::cout << *it << ", ";
		}
	}
	std::cout << ctr << "\n";
}

const IndexPair &InvertedIndex::get(void) const
{
	return indexPair;
}

const std::unordered_set<std::string> &InvertedIndex::words(void) const
{
	return docs;
}
#include "wordle.hpp"

int main(int argc, const char *const argv[])
{
	Wordle wordle{ argc, argv };
}
#include "nytimesfetcher.hpp"

#include <curl/curl.h>
#include <nlohmann/json.hpp>

#include <cstdlib>
#include <ctime>
#include <vector>

std::string NYTimesFetcher::fetch(void) const
{
	curl_global_init(CURL_GLOBAL_DEFAULT);

	CURL	   *curl = curl_easy_init();
	std::string readBuffer{};
	if (curl) {
		std::string url{ buildURL() };
		curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
		curl_easy_perform(curl);
		curl_easy_cleanup(curl);
	}

	curl_global_cleanup();

	auto jsonData = nlohmann::json::parse(readBuffer);
	return jsonData[key].get<std::string>();
}

size_t NYTimesFetcher::write_callback(void *contents, size_t size, size_t nmemb,
				      void *userp)
{
	static_cast<std::string *>(userp)->append(static_cast<char *>(contents),
						  size * nmemb);
	return size * nmemb;
}

std::string NYTimesFetcher::buildURL(void) const
{
	/* Get current date */
	std::time_t t = std::time(nullptr);
	std::tm	    tm;
	localtime_r(&t, &tm);
	char date[DATE_LEN];
	std::strftime(date, DATE_LEN, "%Y-%m-%d", &tm);

	/* Build url */
	std::vector<const char *> buffers{ nytimesURL, date, jsonExt };

	std::string url{};
	url.reserve(URL_LEN);
	for (const auto &s : buffers) {
		url.append(s);
	}
	return url;
}
#include "tilegrid.hpp"

#include <algorithm>
#include <array>
#include <cctype>
#include <iostream>
#include <unordered_map>

#include "doclen.hpp"

TileGrid::TileGrid(const std::string &wordOfDay)
	: wordOfDay{ wordOfDay }
	, letterCounter{ makeLetterCounter() }
{
}

std::unordered_map<char, std::size_t> TileGrid::makeLetterCounter(void) const
{
	std::unordered_map<char, std::size_t> letterCounter{};
	for (const auto &letter : wordOfDay) {
		letterCounter[letter] += 1;
	}
	return letterCounter;
}

void TileGrid::makeTiles(void)
{
	clearTiles();

	auto letterCounter{ this->letterCounter };
	for (std::size_t i = 0; i < DOC_LEN; i++) {
		if ((*guess)[i] == wordOfDay[i]) {
			letterCounter[wordOfDay[i]] -= 1;
			this->tiles[i] = g;
		}
	}

	for (std::size_t i = 0; i < DOC_LEN; i++) {
		if (this->tiles[i] == e) {
			if (letterCounter[(*guess)[i]] > 0) {
				letterCounter[wordOfDay[i]] -= 1;
				this->tiles[i] = y;
			} else {
				this->tiles[i] = x;
			}
		}
	}
}

void TileGrid::feedback(const std::string &guess)
{
	this->guess = &guess;
	makeTiles();
	printTileGrid();
}

bool TileGrid::won(void) const
{
	for (std::size_t i = 0; i < DOC_LEN; i++) {
		if (tiles[i] != g) {
			return false;
		}
	}
	return true;
}

const std::string &TileGrid::word(void) const
{
	return *guess;
}

const std::array<TileGrid::TileState, DOC_LEN> &TileGrid::get(void) const
{
	return tiles;
}

void TileGrid::clearTiles(void)
{
	std::ranges::fill(tiles, e);
}

void TileGrid::printTileGrid(void) const
{
	for (std::size_t i = 0; i < DOC_LEN; i++) {
		char letter = std::toupper((*guess)[i]);
		switch (tiles[i]) {
		case g:
			printTile(letter, G);
			break;
		case y:
			printTile(letter, Y);
			break;
		case x:
			printTile(letter, X);
			break;
		default:
			/* Should not go to default*/
		}
	}
	// std::cout << "\n";
}

void TileGrid::printTile(char letter, const std::array<int, RGB_CHAN> &c) const
{
	std::cout << "\033[48;2;" << c[0] << ";" << c[1] << ";" << c[2] << "m"
		  << "\033[38;2;" << c[3] << ";" << c[4] << ";" << c[5] << "m"
		  << " " << letter << " " << "\033[0m";
}
#include "usetoperations.hpp"

#include <ranges>
#include <unordered_set>

#include "doclen.hpp"

USetOperations::USetOperations(const TileGrid	   &tileGrid,
			       const InvertedIndex &invertedIndex)
	: tileGrid{ tileGrid }
	, invertedIndex{ invertedIndex }
{
}

void USetOperations::uset_union(std::unordered_set<std::string>	      &a,
				const std::unordered_set<std::string> &b)
{
	a.insert(b.begin(), b.end());
}

void USetOperations::uset_intersection(std::unordered_set<std::string>	     &a,
				       const std::unordered_set<std::string> &b)
{
	for (auto it = a.begin(); it != a.end();) {
		if (!b.contains(*it)) {
			it = a.erase(it);
		} else {
			it++;
		}
	}
}

void USetOperations::uset_difference(std::unordered_set<std::string>	   &a,
				     const std::unordered_set<std::string> &b)
{
	for (auto it = a.begin(); it != a.end();) {
		if (b.contains(*it)) {
			it = a.erase(it);
		} else {
			it++;
		}
	}
}

void USetOperations::addCorrect(const std::unordered_set<std::string> &b)
{
	if (correct.empty()) {
		uset_union(correct, b);
	} else {
		uset_intersection(correct, b);
	}
}

void USetOperations::addPresent(const std::unordered_set<std::string> &b,
				char				       letter)
{
	if (presentUMap[letter].empty()) {
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			uset_union(presentUMap[letter],
				   invertedIndex.at(letter, i));
		}
	}
	uset_difference(presentUMap[letter], b);
}

void USetOperations::addAbsent(char letter)
{
	if (!presentUMap.contains(letter)) {
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			uset_union(absent, invertedIndex.at(letter, i));
		}
	}
}

void USetOperations::populate(void)
{
	for (std::size_t pos = 0; pos < DOC_LEN; pos++) {
		const auto &tileState = tileGrid.get()[pos];
		char	    letter    = tileGrid.word()[pos];
		const auto &b{ invertedIndex.at(letter, pos) };
		switch (tileState) {
		case TileGrid::g:
			addCorrect(b);
			break;
		case TileGrid::y:
			addPresent(b, letter);
			break;
		case TileGrid::x:
			addAbsent(letter);
			break;
		default:
			break;
		}
	}
}

void USetOperations::presentAggregate(void)
{
	if (!presentUMap.empty()) {
		for (const auto &p : std::views::values(presentUMap)) {
			uset_union(present, p);
		}
	}
}

std::unordered_set<std::string> USetOperations::execute(void)
{
	populate();
	presentAggregate();
	if (!correct.empty()) {
		if (!present.empty()) {
			uset_intersection(correct, present);
		}
		if (!absent.empty()) {
			uset_difference(correct, absent);
		}
		return correct;
	} else if (!present.empty()) {
		if (!absent.empty()) {
			uset_difference(present, absent);
		}
		return present;
	} else {
		auto result{ invertedIndex.words() };
		uset_difference(result, absent);
		return result;
	}
}
#include "wordle.hpp"

#include <curl/curl.h>

#include <algorithm>
#include <cstdlib>
#include <iostream>

#include "doclen.hpp"
#include "invertedindex.hpp"
#include "nytimesfetcher.hpp"
#include "tilegrid.hpp"
#include "wordleplayer.hpp"
#include "wordscorer.hpp"

const WordlePlayer Wordle::wordlePlayer{};

Wordle::Wordle(int argc, const char *const *argv)
	: prog{ *argv }
	, wordOfDay{ NYTimesFetcher{}.fetch() }
	, tileGrid{ wordOfDay }

{
	parseArgs(argc, argv);
}

void Wordle::play(void)
{
	tileGrid.feedback(wordlePlayer.opener());
	play_helper(wordlePlayer.guess(tileGrid), MAX_TRIES - 1);
}

void Wordle::play_helper(InvertedIndex index, std::size_t tries)
{
	std::cout << "\n";
	if (tries == 0) {
		std::cerr
			<< "ERROR: Wordle player failed to guess the word in at most six tries. This should never happen.\n";
		return;
	}
	tileGrid.feedback(WordScorer{ index }.bestGuess());
	return;
	if (tileGrid.won()) {
		std::cout << "\n";
		return;
	} else {
		play_helper(wordlePlayer.guess(tileGrid, index), tries - 1);
	}
}

void Wordle::peek(void)
{
	std::cout << "Word of the day is ";
	tileGrid.feedback(wordOfDay);
	std::cout
		<< " ( from https://www.nytimes.com/games/wordle/index.html )!\n";
}

void Wordle::benchmark(bool) const
{
}

void Wordle::help(void) const
{
	std::cout
		<< "Usage: " << prog << " COMMAND\n\n"
		<< "Fast and efficient player for Wordle (nytimes.com).\n\n"
		<< "Commands:\n"
		<< "  play [WORD]    Solve word of the day from Wordle (nytimes.com) or solve user-picked 5-letter word\n"
		<< "  peek           Show word of the day\n"
		<< "  bm             Benchmark performance\n"
		<< "  bmv            Benchmark performance verbose\n"
		<< "  help           Show this help message and exit\n"
		<< "\nExamples:\n"
		<< "  " << prog << " play\n"
		<< "  " << prog << " play SHARE\n";
}

void Wordle::setUserWordOfDay(std::string userWord)
{
	if (userWord.size() == DOC_LEN) {
		std::transform(userWord.begin(),
			       userWord.end(),
			       userWord.begin(),
			       ::tolower);
		wordOfDay = std::move(userWord);

	} else {
		help();
		std::exit(EXIT_SUCCESS);
	}
}

void Wordle::parseArgs(int argc, const char *const *argv)
{
	if (argc != 2 && argc != 3) {
		help();
	} else {
		std::string arg{ argv[1] };
		if (arg == "play") {
			if (argc == 3) {
				setUserWordOfDay(std::string{ argv[2] });
			}
			play();
		} else if (arg == "peek") {
			peek();
		} else if (arg == "bm") {
			benchmark(false);
		} else if (arg == "bmv") {
			benchmark(true);
		} else {
			help();
		}
	}
}

void Wordle::setNYTimesWordOfDay(void)
{
	wordOfDay = NYTimesFetcher{}.fetch();

	if (wordOfDay.size() == 0) {
		std::cerr
			<< "ERROR: cURL failed to start or failed to retrieve nytimes.com word of the day.\n";
		std::exit(EXIT_FAILURE);
	}
}
#include "wordleplayer.hpp"

#include <cctype>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <unordered_set>

#include "doclen.hpp"
#include "invertedindex.hpp"
#include "tilegrid.hpp"
#include "usetoperations.hpp"
#include "wordscorer.hpp"

std::unordered_set<std::string> WordlePlayer::readWords(void) const
{
	std::unordered_set<std::string> words{};

	std::ifstream f("../assets/valid-wordle-words.txt");
	if (!f) {
		std::cerr << "ERROR: Unable to open file!\n";
		std::exit(EXIT_FAILURE);
	}
	words.reserve(MAX_DOCS);
	std::string word{};
	word.reserve(DOC_LEN);
	while (std::getline(f, word)) {
		words.insert(std::move(word));
	}
	f.close();
	return words;
}

void WordlePlayer::printWords(void) const
{
	for (const auto &word : words) {
		std::cout << word << "\n";
	}
}

std::string WordlePlayer::setBestOpener(void) const
{
	/* Hardcoded to PARES from word scoring entire list */
	return std::string{ "pares" };
}

WordlePlayer::WordlePlayer(void)
	: words{ readWords() }
	, bestOpener{ setBestOpener() }
	, startIndex{ words }

{
	// printWords();
}

InvertedIndex WordlePlayer::guess(const TileGrid      &tileGrid,
				  const InvertedIndex &index) const
{
	return InvertedIndex{
		USetOperations{ tileGrid, index }
		 .execute()
	};
}

InvertedIndex WordlePlayer::guess(const TileGrid &tileGrid) const
{
	return InvertedIndex{
		USetOperations{ tileGrid, startIndex }
		      .execute()
	};
}

const std::string &WordlePlayer::opener(void) const
{
	return bestOpener;
}
#include "wordscorer.hpp"

#include <iostream>

#include "doclen.hpp"
#include "invertedindex.hpp"

WordScorer::WordScorer(const InvertedIndex &index)
	: index{ index }
{
}

const std::string &WordScorer::bestGuess(void)
{
	const std::string *bestGuess{};
	std::size_t	   bestScore{ 0 };

	std::unordered_set<char> letterSet;
	for (const auto &word : index.words()) {
		std::size_t currScore{ 0 };
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			char letter = word[i];
			if (letterSet.contains(letter)) {
				continue;
			}
			currScore += index.frequency(letter, i);
			letterSet.insert(letter);
		}
		letterSet.clear();
		if (currScore > bestScore) {
			bestScore = currScore;
			bestGuess = &word;
		}
	}
	return *bestGuess;
}
#pragma once

#include <cstddef>

constexpr std::size_t DOC_LEN = 5;
#pragma once

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>

using IndexPair = std::pair<
	std::unordered_map<std::string, std::unordered_set<std::string> >,
	std::unordered_map<std::string, std::size_t> >;

class InvertedIndex {
    private:
	static constexpr std::size_t MAX_KEYS = 130;

	const std::unordered_set<std::string> &docs;
	const IndexPair			       indexPair;

	std::unordered_set<std::string> makeKeys(void) const;
	IndexPair			makeIndexPair(void) const;

	// void printIndices(void) const;
	void printInvertedIndex(void) const;

    public:
	InvertedIndex(const std::unordered_set<std::string> &);

	const IndexPair			      &get(void) const;
	const std::unordered_set<std::string> &words(void) const;

	std::string key(char, std::size_t) const;

	const std::unordered_set<std::string> &at(char, std::size_t) const;
	std::size_t frequency(char, std::size_t) const;
};
#pragma once

#include <string>

class NYTimesFetcher {
    private:
	static constexpr std::size_t DATE_LEN = 11;
	static constexpr std::size_t URL_LEN  = 53;
	static constexpr const char *nytimesURL =
		"https://www.nytimes.com/svc/wordle/v2/";
	static constexpr const char *jsonExt = ".json";
	static constexpr const char *key     = "solution";

	static size_t write_callback(void *, size_t, size_t, void *);

	std::string buildURL(void) const;

    public:
	std::string fetch(void) const;
};
#pragma once

#include <array>
#include <string>
#include <unordered_map>

#include "doclen.hpp"

class TileGrid {
    public:
	enum TileState { e, g, y, x };

	TileGrid(const std::string &);
	void feedback(const std::string &);

	const std::array<TileState, DOC_LEN> &get(void) const;
	const std::string		     &word(void) const;
	bool				      won(void) const;

    private:
	static constexpr std::size_t RGB_CHAN = 6;
	static constexpr std::array<int, RGB_CHAN> G{
		83, 141, 78, 248, 248, 248
	};
	static constexpr std::array<int, RGB_CHAN> Y{ 181, 159, 59,
						      248, 248, 248 };
	static constexpr std::array<int, RGB_CHAN> X{
		58, 58, 60, 255, 255, 255
	};

	const std::string &wordOfDay;

	const std::unordered_map<char, std::size_t> letterCounter;

	const std::string *guess;

	std::array<TileState, DOC_LEN> tiles;

	std::unordered_map<char, std::size_t> makeLetterCounter(void) const;

	void printTileGrid(void) const;
	void printTile(char, const std::array<int, RGB_CHAN> &) const;

	void makeTiles(void);
	void clearTiles(void);
};
#pragma once

#include <unordered_map>
#include <unordered_set>

#include "invertedindex.hpp"
#include "tilegrid.hpp"

class USetOperations {
    private:
	const TileGrid	    &tileGrid;
	const InvertedIndex &invertedIndex;

	std::unordered_set<std::string>				   correct;
	std::unordered_map<char, std::unordered_set<std::string> > presentUMap;
	std::unordered_set<std::string>				   present;
	std::unordered_set<std::string>				   absent;

	std::unordered_set<std::string> result;

	void addCorrect(const std::unordered_set<std::string> &);
	void addPresent(const std::unordered_set<std::string> &, char);
	void addAbsent(char);
	void populate(void);
	void presentAggregate(void);

	void uset_union(std::unordered_set<std::string> &,
			const std::unordered_set<std::string> &);
	void uset_intersection(std::unordered_set<std::string> &,
			       const std::unordered_set<std::string> &);
	void uset_difference(std::unordered_set<std::string> &,
			     const std::unordered_set<std::string> &);

    public:
	USetOperations(const TileGrid &, const InvertedIndex &);
	std::unordered_set<std::string> execute(void);
};
#pragma once

#include <string>

#include "invertedindex.hpp"
#include "tilegrid.hpp"
#include "wordleplayer.hpp"

class Wordle {
    private:
	static constexpr std::size_t MAX_TRIES = 6;
	static const WordlePlayer    wordlePlayer;

	const char *const prog;

	std::string wordOfDay;

	TileGrid tileGrid;

	void play(void);
	void play_helper(InvertedIndex, std::size_t);
	void peek(void);
	void benchmark(bool) const;
	void help(void) const;

	void parseArgs(int argc, const char *const *argv);
	void setUserWordOfDay(std::string);
	void setNYTimesWordOfDay(void);

    public:
	Wordle(int, const char *const *);
};
#pragma once

#include <string>
#include <unordered_set>

#include "invertedindex.hpp"
#include "tilegrid.hpp"

class WordlePlayer {
    private:
	static constexpr std::size_t MAX_DOCS = 15000;

	const std::unordered_set<std::string> words;

	const std::string bestOpener;

	const InvertedIndex startIndex;

	std::unordered_set<std::string> readWords(void) const;

	std::string setBestOpener(void) const;

	void printWords(void) const;

    public:
	WordlePlayer(void);

	InvertedIndex guess(const TileGrid &, const InvertedIndex &) const;
	InvertedIndex guess(const TileGrid &) const;

	const std::string &opener(void) const;
};
#pragma once

#include "invertedindex.hpp"

class WordScorer {
    private:
	const InvertedIndex &index;

    public:
	WordScorer(const InvertedIndex &);
	const std::string &bestGuess(void);
};
