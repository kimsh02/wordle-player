#include "invertedindex.hpp"

#include <iostream>
#include <string>
#include <unordered_map>

#include "doclen.hpp"

InvertedIndex::InvertedIndex(const std::unordered_set<std::string> &docs)
	: docs{ docs }
	, indexPair{ makeIndexPair() }
{
	// printInvertedIndex();
}

// InvertedIndex::InvertedIndex(std::unordered_set<std::string> docs)
// 	: docs{ docs }
// {
// }

// std::unordered_set<std::string> &InvertedIndex::giveWords(void)
// {
// 	return docs;
// }

std::string InvertedIndex::key(char letter, std::size_t pos) const
{
	return std::string{ letter, static_cast<char>(pos + '0') };
}

bool InvertedIndex::contains(char letter, std::size_t pos) const
{
	return indexPair.first.contains(key(letter, pos));
}

const std::unordered_set<std::string> &InvertedIndex::at(char	     letter,
							 std::size_t pos) const
{
	return indexPair.first.at(key(letter, pos));
}

std::size_t InvertedIndex::frequency(char letter, std::size_t pos) const
{
	return indexPair.second.at(key(letter, pos));
}

std::unordered_set<std::string> InvertedIndex::makeKeys(void) const
{
	std::unordered_set<std::string> keys{};
	keys.reserve(MAX_KEYS);
	for (const auto &doc : docs) {
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			keys.emplace(key(doc[i], i));
		}
		if (keys.size() == 130) {
			break;
		}
	}
	return keys;
}

// void InvertedIndex::printIndices(void) const
// {
// 	for (const auto &i : indices) {
// 		std::cout << i << "\n";
// 	}
// 	std::cout << indices.size() << "\n";
// }

IndexPair InvertedIndex::makeIndexPair(void) const
{
	auto	  keys{ makeKeys() };
	IndexPair indexPair{};
	indexPair.first.reserve(keys.size());
	indexPair.second.reserve(keys.size());
	for (const auto &i : keys) {
		char	    letter = i[0];
		std::size_t pos	   = i[1] - '0';
		for (const auto &doc : docs) {
			if (doc[pos] == letter) {
				indexPair.first[i].insert(doc);
			}
		}
		indexPair.second[i] = indexPair.first[i].size();
	}
	return indexPair;
}

void InvertedIndex::printInvertedIndex(void) const
{
	std::size_t ctr = 0;
	for (const auto &[key, value] : indexPair.first) {
		std::cout << "{ " << key << " }: [";
		std::size_t i = 0;
		ctr += value.size();
		for (auto it = value.begin(); it != value.end(); it++, i++) {
			if (i == value.size() - 1) {
				std::cout << *it << "]\n";
				break;
			}
			std::cout << *it << ", ";
		}
	}
	std::cout << ctr << "\n";
}

const IndexPair &InvertedIndex::get(void) const
{
	return indexPair;
}

const std::unordered_set<std::string> &InvertedIndex::words(void) const
{
	return docs;
}
#include "wordle.hpp"

int main(int argc, const char *const argv[])
{
	Wordle wordle{ argc, argv };
}
#include "nytimesfetcher.hpp"

#include <curl/curl.h>
#include <nlohmann/json.hpp>

#include <cstdlib>
#include <ctime>
#include <vector>

std::string NYTimesFetcher::fetch(void) const
{
	curl_global_init(CURL_GLOBAL_DEFAULT);

	CURL	   *curl = curl_easy_init();
	std::string readBuffer{};
	if (curl) {
		std::string url{ buildURL() };
		curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
		curl_easy_perform(curl);
		curl_easy_cleanup(curl);
	}

	curl_global_cleanup();

	auto jsonData = nlohmann::json::parse(readBuffer);
	return jsonData[key].get<std::string>();
}

size_t NYTimesFetcher::write_callback(void *contents, size_t size, size_t nmemb,
				      void *userp)
{
	static_cast<std::string *>(userp)->append(static_cast<char *>(contents),
						  size * nmemb);
	return size * nmemb;
}

std::string NYTimesFetcher::buildURL(void) const
{
	/* Get current date */
	std::time_t t = std::time(nullptr);
	std::tm	    tm;
	localtime_r(&t, &tm);
	char date[DATE_LEN];
	std::strftime(date, DATE_LEN, "%Y-%m-%d", &tm);

	/* Build url */
	std::vector<const char *> buffers{ nytimesURL, date, jsonExt };

	std::string url{};
	url.reserve(URL_LEN);
	for (const auto &s : buffers) {
		url.append(s);
	}
	return url;
}
#include "tilegrid.hpp"

#include <algorithm>
#include <array>
#include <cctype>
#include <iostream>
#include <unordered_map>

#include "doclen.hpp"

void TileGrid::setWordOfDay(const std::string &wordOfDay)
{
	this->wordOfDay = wordOfDay;
	makeLetterCounter();
}

void TileGrid::makeLetterCounter(void)
{
	letterCounter.clear();
	for (const auto &letter : wordOfDay) {
		letterCounter[letter] += 1;
	}
}

void TileGrid::makeTiles(void)
{
	clearTiles();

	auto letterCounter{ this->letterCounter };
	for (std::size_t i = 0; i < DOC_LEN; i++) {
		if ((guess)[i] == (wordOfDay)[i]) {
			letterCounter[(wordOfDay)[i]] -= 1;
			this->tiles[i] = g;
		}
	}

	for (std::size_t i = 0; i < DOC_LEN; i++) {
		if (this->tiles[i] == e) {
			// / Letter is present in word of day /
			if (letterCounter[(guess)[i]] > 0) {
				letterCounter[(guess)[i]] -= 1;
				this->tiles[i] = y;
			} else {
				this->tiles[i] = x;
			}
		}
	}
}

void TileGrid::feedback(const std::string &guess)
{
	this->guess = guess;
	makeTiles();
	printTileGrid();
}

bool TileGrid::won(void) const
{
	for (std::size_t i = 0; i < DOC_LEN; i++) {
		if (tiles[i] != g) {
			return false;
		}
	}
	return true;
}

const std::string &TileGrid::getWordOfDay(void) const
{
	return wordOfDay;
}

const std::string &TileGrid::getGuess(void) const
{
	return guess;
}

const std::array<TileGrid::TileState, DOC_LEN> &
TileGrid::getFeedback(void) const
{
	return tiles;
}

void TileGrid::clearTiles(void)
{
	std::ranges::fill(tiles, e);
}

void TileGrid::printTileGrid(void) const
{
	for (std::size_t i = 0; i < DOC_LEN; i++) {
		char letter = std::toupper((guess)[i]);
		switch (tiles[i]) {
		case g:
			printTile(letter, G);
			break;
		case y:
			printTile(letter, Y);
			break;
		case x:
			printTile(letter, X);
			break;
		default:
			// Should not go to default
		}
	}
	// std::cout << "\n";
}

void TileGrid::printTile(char letter, const std::array<int, RGB_CHAN> &c) const
{
	std::cout << "\033[48;2;" << c[0] << ";" << c[1] << ";" << c[2] << "m"
		  << "\033[38;2;" << c[3] << ";" << c[4] << ";" << c[5] << "m"
		  << " " << letter << " " << "\033[0m";
}
#include "usetoperations.hpp"

#include <iostream>
#include <ranges>
#include <unordered_set>

#include "doclen.hpp"

void USetOperations::input(const TileGrid      &tileGrid,
			   const InvertedIndex &invertedIndex)
{
	this->tileGrid	    = &tileGrid;
	this->invertedIndex = &invertedIndex;
}

void USetOperations::uset_union(std::unordered_set<std::string>	      &a,
				const std::unordered_set<std::string> &b)
{
	a.insert(b.begin(), b.end());
}

void USetOperations::uset_intersection(std::unordered_set<std::string>	     &a,
				       const std::unordered_set<std::string> &b)
{
	for (auto it = a.begin(); it != a.end();) {
		if (!b.contains(*it)) {
			it = a.erase(it);
		} else {
			it++;
		}
	}
}

void USetOperations::uset_difference(std::unordered_set<std::string>	   &a,
				     const std::unordered_set<std::string> &b)
{
	for (auto it = a.begin(); it != a.end();) {
		if (b.contains(*it)) {
			it = a.erase(it);
		} else {
			it++;
		}
	}
}

void USetOperations::addCorrect(const std::unordered_set<std::string> &b)
{
	if (correct.empty()) {
		uset_union(correct, b);
	} else {
		uset_intersection(correct, b);
	}
}

void USetOperations::addPresent(char letter, std::size_t pos)
{
	presentUMap[letter].insert(pos);
}

void USetOperations::addAbsent(char letter, std::size_t pos)
{
	if (!presentUMap.contains(letter)) {
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			if (invertedIndex->contains(letter, i)) {
				uset_union(absent,
					   invertedIndex->at(letter, i));
			}
		}
	} else {
		uset_union(absent, invertedIndex->at(letter, pos));
	}
}

void USetOperations::populate(void)
{
	for (std::size_t pos = 0; pos < DOC_LEN; pos++) {
		const auto &tileState = tileGrid->getFeedback()[pos];
		char	    letter    = tileGrid->getGuess()[pos];
		const auto &b{ invertedIndex->at(letter, pos) };
		switch (tileState) {
		case TileGrid::g:
			addCorrect(b);
			break;
		case TileGrid::y:
			addPresent(letter, pos);
			break;
		case TileGrid::x:
			addAbsent(letter, pos);
			break;
		default:
			break;
		}
	}
}

void USetOperations::presentFilter(void)
{
	for (const auto &[key, value] : presentUMap) {
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			if (value.contains(i)) {
				uset_union(absent, invertedIndex->at(key, i));
			} else if (invertedIndex->contains(key, i)) {
				uset_union(present, invertedIndex->at(key, i));
			}
		}
	}
}

void USetOperations::clear(void)
{
	correct.clear();
	presentUMap.clear();
	present.clear();
	absent.clear();
	result.clear();
}

std::unordered_set<std::string> USetOperations::execute(void)
{
	clear();
	populate();
	presentFilter();
	if (!correct.empty()) {
		if (!present.empty()) {
			uset_intersection(correct, present);
		}
		if (!absent.empty()) {
			uset_difference(correct, absent);
		}
		return correct;
	} else if (!present.empty()) {
		if (!absent.empty()) {
			uset_difference(present, absent);
		}
		return present;
	} else {
		result = invertedIndex->words();
		uset_difference(result, absent);
		return result;
	}
}
#include "wordle.hpp"

#include <curl/curl.h>

#include <algorithm>
#include <cstdlib>
#include <iostream>

#include "doclen.hpp"
#include "invertedindex.hpp"
#include "nytimesfetcher.hpp"
#include "tilegrid.hpp"
#include "wordleplayer.hpp"
#include "wordscorer.hpp"

WordlePlayer Wordle::wordlePlayer{};

Wordle::Wordle(int argc, const char *const *argv)
	: prog{ *argv }
	, wordOfDay{ NYTimesFetcher{}.fetch() }
{
	parseArgs(argc, argv);
}

void Wordle::play(void)
{
	tileGrid.feedback(wordlePlayer.opener());
	play_helper(wordlePlayer.guess(tileGrid), MAX_TRIES - 1);
}

void Wordle::play_helper(InvertedIndex index, std::size_t tries)
{
	std::cout << "\n";
	// index.printInvertedIndex();
	std::cout << std::boolalpha << index.words().contains("bears") << "\n";
	if (tries == 0) {
		std::cerr
			<< "ERROR: Wordle player failed to guess the word in at most six tries. This should never happen.\n";
		return;
	}
	tileGrid.feedback(WordScorer{ index }.bestGuess());
	if (tileGrid.won()) {
		std::cout << "\n";
		return;
	} else {
		play_helper(wordlePlayer.guess(tileGrid, index), tries - 1);
	}
}

void Wordle::peek(void)
{
	std::cout << "Word of the day is ";
	tileGrid.feedback(wordOfDay);
	std::cout
		<< " ( from https://www.nytimes.com/games/wordle/index.html )!\n";
}

void Wordle::benchmark(bool) const
{
}

void Wordle::help(void) const
{
	std::cout
		<< "Usage: " << prog << " COMMAND\n\n"
		<< "Fast and efficient player for Wordle (nytimes.com).\n\n"
		<< "Commands:\n"
		<< "  play [WORD]    Solve word of the day from Wordle (nytimes.com) or solve user-picked 5-letter word\n"
		<< "  peek           Show word of the day\n"
		<< "  bm             Benchmark performance\n"
		<< "  bmv            Benchmark performance verbose\n"
		<< "  help           Show this help message and exit\n"
		<< "\nExamples:\n"
		<< "  " << prog << " play\n"
		<< "  " << prog << " play SHARE\n";
}

void Wordle::setUserWordOfDay(std::string userWord)
{
	/* Check if it's valid 5 letter word */

	if (userWord.size() == DOC_LEN) {
		std::transform(userWord.begin(),
			       userWord.end(),
			       userWord.begin(),
			       ::tolower);
		if (wordlePlayer.getWords().contains(userWord)) {
			wordOfDay = userWord;
			return;
		}
	}
	help();
	std::exit(EXIT_SUCCESS);
}

void Wordle::parseArgs(int argc, const char *const *argv)
{
	if (argc != 2 && argc != 3) {
		help();
	} else {
		std::string arg{ argv[1] };
		if (arg == "play") {
			if (argc == 3) {
				setUserWordOfDay(std::string{ argv[2] });
			}
			tileGrid.setWordOfDay(wordOfDay);
			play();
		} else if (arg == "peek") {
			peek();
		} else if (arg == "bm") {
			benchmark(false);
		} else if (arg == "bmv") {
			benchmark(true);
		} else {
			help();
		}
	}
}

void Wordle::setNYTimesWordOfDay(void)
{
	wordOfDay = NYTimesFetcher{}.fetch();

	if (wordOfDay.size() == 0) {
		std::cerr
			<< "ERROR: cURL failed to start or failed to retrieve nytimes.com word of the day.\n";
		std::exit(EXIT_FAILURE);
	}
}
#include "wordleplayer.hpp"

#include <cctype>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <unordered_set>

#include "doclen.hpp"
#include "invertedindex.hpp"
#include "tilegrid.hpp"
#include "usetoperations.hpp"
#include "wordscorer.hpp"

std::unordered_set<std::string> WordlePlayer::readWords(void) const
{
	std::unordered_set<std::string> words{};

	std::ifstream f("../assets/valid-wordle-words.txt");
	if (!f) {
		std::cerr << "ERROR: Unable to open file!\n";
		std::exit(EXIT_FAILURE);
	}
	words.reserve(MAX_DOCS);
	std::string word{};
	word.reserve(DOC_LEN);
	while (std::getline(f, word)) {
		words.insert(std::move(word));
	}
	f.close();
	return words;
}

void WordlePlayer::printWords(void) const
{
	for (const auto &word : words) {
		std::cout << word << "\n";
	}
}

std::string WordlePlayer::setBestOpener(void) const
{
	/* Hardcoded to PARES from word scoring entire list */
	return std::string{ "reins" };
}

WordlePlayer::WordlePlayer(void)
	: words{ readWords() }
	, bestOpener{ setBestOpener() }
	, startIndex{ words }

{
	// printWords();
}

const std::unordered_set<std::string> &WordlePlayer::getWords(void) const
{
	return startIndex.words();
}

InvertedIndex WordlePlayer::guess(const TileGrid      &tileGrid,
				  const InvertedIndex &index)
{
	// index.printInvertedIndex();
	usetop.input(tileGrid, index);
	return InvertedIndex{ std::move(usetop.execute()) };
	// InvertedIndex idx{ (usetop.execute()) };
	// return InvertedIndex{ (usetop.execute()) };
	// return idx;
}

InvertedIndex WordlePlayer::guess(const TileGrid &tileGrid)
{
	usetop.input(tileGrid, startIndex);
	return InvertedIndex{ std::move(usetop.execute()) };
	// return InvertedIndex{ (usetop.execute()) };
}

const std::string &WordlePlayer::opener(void) const
{
	return bestOpener;
}
#include "wordscorer.hpp"

#include <iostream>

#include "doclen.hpp"
#include "invertedindex.hpp"

WordScorer::WordScorer(const InvertedIndex &index)
	: index{ index }
{
}

std::string WordScorer::bestGuess(void)
{
	std::string bestGuess{};
	std::size_t bestScore{ 0 };

	std::unordered_set<char> letterSet;
	for (const auto &word : index.words()) {
		std::size_t currScore{ 0 };
		for (std::size_t i = 0; i < DOC_LEN; i++) {
			char letter = word[i];
			if (letterSet.contains(letter)) {
				currScore += index.frequency(letter, i) / 2;
			} else {
				currScore += index.frequency(letter, i);
			}
			letterSet.insert(letter);
		}
		letterSet.clear();
		if (currScore > bestScore) {
			bestScore = currScore;
			bestGuess = word;
		}
	}
	return bestGuess;
}
#pragma once

#include <cstddef>

constexpr std::size_t DOC_LEN = 5;
#pragma once

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>

using IndexPair = std::pair<
	std::unordered_map<std::string, std::unordered_set<std::string> >,
	std::unordered_map<std::string, std::size_t> >;

class InvertedIndex {
    private:
	static constexpr std::size_t MAX_KEYS = 130;

	/* By value, and std::move */
	const std::unordered_set<std::string> docs;
	const IndexPair			      indexPair;

	std::unordered_set<std::string> makeKeys(void) const;
	IndexPair			makeIndexPair(void) const;

	// void printIndices(void) const;

    public:
	InvertedIndex(const std::unordered_set<std::string> &);
	// InvertedIndex(std::unordered_set<std::string>);

	void printInvertedIndex(void) const;

	const IndexPair			      &get(void) const;
	const std::unordered_set<std::string> &words(void) const;
	// std::unordered_set<std::string>	      &giveWords(void);

	std::string key(char, std::size_t) const;

	const std::unordered_set<std::string> &at(char, std::size_t) const;
	bool contains(char, std::size_t) const;

	std::size_t frequency(char, std::size_t) const;
};
#pragma once

#include <string>

class NYTimesFetcher {
    private:
	static constexpr std::size_t DATE_LEN = 11;
	static constexpr std::size_t URL_LEN  = 53;
	static constexpr const char *nytimesURL =
		"https://www.nytimes.com/svc/wordle/v2/";
	static constexpr const char *jsonExt = ".json";
	static constexpr const char *key     = "solution";

	static size_t write_callback(void *, size_t, size_t, void *);

	std::string buildURL(void) const;

    public:
	std::string fetch(void) const;
};
#pragma once

#include <array>
#include <string>
#include <unordered_map>

#include "doclen.hpp"

class TileGrid {
    public:
	enum TileState { e, g, y, x };

	void feedback(const std::string &);

	const std::array<TileState, DOC_LEN> &getFeedback(void) const;
	const std::string		     &getGuess(void) const;
	const std::string		     &getWordOfDay(void) const;

	void setWordOfDay(const std::string &);
	bool won(void) const;

    private:
	static constexpr std::size_t RGB_CHAN = 6;
	static constexpr std::array<int, RGB_CHAN> G{
		83, 141, 78, 248, 248, 248
	};
	static constexpr std::array<int, RGB_CHAN> Y{ 181, 159, 59,
						      248, 248, 248 };
	static constexpr std::array<int, RGB_CHAN> X{
		58, 58, 60, 255, 255, 255
	};

	std::string wordOfDay;

	std::unordered_map<char, std::size_t> letterCounter;

	std::string guess;

	std::array<TileState, DOC_LEN> tiles;

	void makeLetterCounter(void);

	void printTileGrid(void) const;
	void printTile(char, const std::array<int, RGB_CHAN> &) const;

	void makeTiles(void);
	void clearTiles(void);
};
#pragma once

#include <unordered_map>
#include <unordered_set>

#include "invertedindex.hpp"
#include "tilegrid.hpp"

using PresentUMap = std::unordered_map<char, std::unordered_set<std::size_t> >;

class USetOperations {
    private:
	const TileGrid	    *tileGrid;
	const InvertedIndex *invertedIndex;

	std::unordered_set<std::string> correct;
	PresentUMap			presentUMap;
	std::unordered_set<std::string> present;
	std::unordered_set<std::string> absent;
	std::unordered_set<std::string> result;

	void addCorrect(const std::unordered_set<std::string> &);
	void addPresent(char, std::size_t);
	void addAbsent(char, std::size_t);
	void populate(void);
	void presentFilter(void);
	void clear(void);

	void uset_union(std::unordered_set<std::string> &,
			const std::unordered_set<std::string> &);
	void uset_intersection(std::unordered_set<std::string> &,
			       const std::unordered_set<std::string> &);
	void uset_difference(std::unordered_set<std::string> &,
			     const std::unordered_set<std::string> &);

	// void printSet(void) const;

    public:
	void input(const TileGrid &, const InvertedIndex &);
	std::unordered_set<std::string> execute(void);
};
#pragma once

#include <string>

#include "invertedindex.hpp"
#include "tilegrid.hpp"
#include "wordleplayer.hpp"

class Wordle {
    private:
	static constexpr std::size_t MAX_TRIES = 6;
	static WordlePlayer	     wordlePlayer;

	const char *const prog;

	std::string wordOfDay;

	TileGrid tileGrid;

	void play(void);
	void play_helper(InvertedIndex, std::size_t);
	void peek(void);
	void benchmark(bool) const;
	void help(void) const;

	void parseArgs(int argc, const char *const *argv);
	void setUserWordOfDay(std::string);
	void setNYTimesWordOfDay(void);

    public:
	Wordle(int, const char *const *);
};
#pragma once

#include <string>
#include <unordered_set>

#include "invertedindex.hpp"
#include "tilegrid.hpp"
#include "usetoperations.hpp"

class WordlePlayer {
    private:
	static constexpr std::size_t MAX_DOCS = 15000;

	const std::unordered_set<std::string> words;

	const std::string bestOpener;

	const InvertedIndex startIndex;

	USetOperations usetop;

	std::unordered_set<std::string> readWords(void) const;

	std::string setBestOpener(void) const;

	void printWords(void) const;

    public:
	WordlePlayer(void);

	InvertedIndex guess(const TileGrid &, const InvertedIndex &);
	InvertedIndex guess(const TileGrid &);

	const std::unordered_set<std::string> &getWords(void) const;

	const std::string &opener(void) const;
};
#pragma once

#include "invertedindex.hpp"

class WordScorer {
    private:
	const InvertedIndex &index;

    public:
	WordScorer(const InvertedIndex &);
	std::string bestGuess(void);
};
